#----需求脚本整理----
#删除/home/web/mysql  /home/web/oracle 这两个目录中2天前的*.log 和*.txt文件
#清空/home/web/mysql  /home/web/oracle 这两个目录中*.out的文件 

#bin/bash
for DIR in {/home/web/mysql,/home/web/oracle}
do
find $DIR -mtime +2 -name "*.log" -exec rm -rf {} \;&>/dev/null
find $DIR -mtime +2 -name "*.txt" -exec rm -rf {} \;&>/dev/null
done

find $DIR -name "*.out" -exec sed -i '1,$s//' {} \;
dir1="$(find /home/web/msysql -name "*.out")"
dir2=`find /home/web/oracle -name "*.out"`
for FILE in "$dir1 $dir2"
do 
echo  > $FILE
done



#----资料积累----
# 总核数 = 物理CPU个数 X 每颗物理CPU的核数 
# 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数
# 查看物理CPU个数
cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
# 查看每个物理CPU中core的个数(即核数)
cat /proc/cpuinfo| grep "cpu cores"| uniq
# 查看逻辑CPU的个数
cat /proc/cpuinfo| grep "processor"| wc -l


#----lscpu命令，查看的是cpu的统计信息----
# lscpu
Architecture:          i686            #cpu架构
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian   #小尾序
CPU(s):                4               #总共有4核
On-line CPU(s) list:   0-3
Thread(s) per core:    1               #每个cpu核，只能支持一个线程，即不支持超线程
Core(s) per socket:    4               #每个cpu，有4个核
Socket(s):             1               #总共有1一个cpu
Vendor ID:             GenuineIntel    #cpu产商 intel
CPU family:            6
Model:                 42
Stepping:              7
CPU MHz:               1600.000
BogoMIPS:              5986.12
Virtualization:        VT-x            #支持cpu虚拟化技术
L1d cache:             32K
L1i cache:             32K
L2 cache:              256K
L3 cache:              6144K

#查看/proc/cpuinfo,可以知道每个cpu信息，如每个CPU的型号，主频等。
#cat /proc/cpuinfo
processor    : 0
vendor_id    : GenuineIntel
cpu family    : 6
model        : 42
model name    : Intel(R) Core(TM) i5-2320 CPU @ 3.00GHz

#修改hostname有几种方式?
1： hostname DB-Server                             --运行后立即生效（新会话生效），但是在系统重启后会丢失所做的修改
2： echo DB-Server  > /proc/sys/kernel/hostname    --运行后立即生效（新会话生效），但是在系统重启后会丢失所做的修改
3： sysctl kernel.hostname=DB-Server               --运行后立即生效（新会话生效），但是在系统重启后会丢失所做的修改
4: 修改/etc/sysconfig/network下的HOSTNAME变量       --需要重启生效，永久性修改。

#删除原先的java命令环境变量指向地址
rm -r $(which(java))

#跟踪dig的查询路径 
Dig是domain information groper的缩写
你可能是个traceroute的狂热爱好者，经常喜欢查看如何从点A连接点B。那你可以使用dig +trace选项做类似的事。
dig gentoo.de +trace
你可以在dig输出的头部分看到根DNS，然后找到负责解析所有*.de的DNS，最后找到gentoo.de的域名IP


#-----vim技巧-----
grep -v "^$""     #过滤空白符            
grep -v "^#"      #不显示以#号开头的行     
#在全部内容的行首添加 # 号注释
:% s/^/#/g 
#在1~10 行首添加 # 号注释
:1,10 s/^/#/g 
#删除所有内容
:.,$d



查看所属root用户进程所打开的文件类型为txt的文件
# lsof -a -u root -d txt
查看8000端口运行情况
# lsof -i :8000

查看当前是否有进程打开/var/logmessages文件
# lsof |grep /var/log/messages
syslogd   1283      root    2w      REG        3,3  5381017    1773647 /var/log/messages (deleted)
如果可以通过文件描述符查看相应的数据，那么就可以使用 I/O 重定向将其复制到文件中，如: 
cat /proc/1283/fd/2 > /var/log/messages 
对于许多应用程序，尤其是日志文件和数据库，这种恢复删除文件的方法非常有用

#如何永久修改系统时间
date       //本年本地时间
hwclock -r //查看硬件时间
hwclock --set --date '2015-8-31 13:24:00' //此处填上你想修改的硬件时间。
hwclock --hctosys //设置硬件时间与系统时间同步。
hwclock -w //保存时间
init 6     //快速重启

#-----常用yum命令-----
# yum clean all (清除缓存)
# yum makecache (建立新缓存)

#查看当前TCP连接的状态和对应的连接数量，一般只关心TIME_WAIT的个数。端口的数量只有65535个，占用一个少一个，会严重的影响到后继的新连接。这种情况下，我们就有必要调整下Linux的TCP内核参数，让系统更快的释放TIME_WAIT连接。
[root@system1 ~]# sysctl -p
[root@system1 ~]# netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'         
ESTABLISHED 43  

#vim /etc/sysctl.conf
net.ipv4.tcp_tw_reuse = 1
#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；
net.ipv4.tcp_fin_timeout
#修改系統默认的 TIMEOUT 时间。

#-----find实用命令-----
#删除一个月之前的所有文件
# find . -mtime +29 -exec rm -rf {} \;
#统计排序大小一周之前大于100M的文件
# find . -size +100M -a -mtime 7  -exec ls -lhS {} \;
#查询当前目录下前一天所有文件总大小：
# find . -mtime -1 -type f -ls |awk '{sum+=$1}END{print sum}'
1457223926
#目录下30分钟内的文件，并逐行为这个文件添加行头 1234
# find . -type f -amin -30 -exec sed -i 's/^/1234/' {} \;






















